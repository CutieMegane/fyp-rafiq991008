<?php

namespace App\Http\Controllers;

use App\Models\Certs;
use Illuminate\Support\Facades\Validator;
use KzykHys\Steganography\Processor;
use ZipArchive;
use Kreait\Firebase;
use Kreait\Firebase\Factory;
use Illuminate\Http\Request;

class CertsAPI extends Controller
{
    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        //firebase test
        $firebase = (new Factory)
        ->withServiceAccount(base_path()."/firebase_credentials.json")
        ->withDatabaseUri('https://fyp-extended-default-rtdb.asia-southeast1.firebasedatabase.app');

        $database = $firebase->createDatabase();

        $key = $database
            ->getReference('Entry1');

        return response()->json($key->getValue());
    }

    public function certValidator(Request $request)
    {
        //prevent weird file variable
        if(!$request->file) return response("Empty?", 418);
        if(Validator::make($request->all(), ['file' => 'file',])->fails()) return response("oh please", 418);

        if (!Validator::make($request->all(), ['file' => 'mimes:zip',])->fails()) {
            $zip = new ZipArchive;
            $zip->open($request->file("file")->getRealPath());

            //check if zip is generated by us or not, our zip only have single image
            if ($zip->count() > 1)
                return response("This compressed zip is modified. Our zip file have only single image inside. :)", 418);

            $fname = $zip->getNameIndex(0);
            $zip->extractTo(storage_path("app/temp/"));
            $zip->close();
            $img = storage_path("app/temp/" . $fname);
            $needCleanup = true;
        } else {
            $img = $request->file->path();
            $needCleanup = false;
        }

        //check if png
        if (pathinfo($img, PATHINFO_EXTENSION) == "png" || !Validator::make($request->all(), ['file' => 'mimes:png',])->fails()) {
            $hess = hash_file("sha256", $img);
            $stego = new Processor;
            try { //if steganography not exist it will return error, simple library weaknesses
                $stego_mark = $stego->decode($img);
            } catch (\Throwable $th) {
                $stego_mark = null;
            }

            //zip temp cleanup within loop- all key is in memory already
            if ($needCleanup) unlink($img);

            //check with hash first, if mismatch, stego also will mismatch
            if (Certs::where('hash', '=',  $hess)->exists()) {

                //check stego integrity, maybe file is forged with hash collision (low chance)
                if (Certs::where('stego_mark', '=', $stego_mark)->exists())
                    return response()->json(Certs::where('stego_mark', '=', $stego_mark)->first());
                else 
                    return response()->json(Certs::where('hash', '=', $hess)->first());
            } else return response("No matching found in database, the files might be processed, compressed or modified.", 418);
        }
        //quirks - need to cleanup before return. Return calls break execution
        else $message = 'This system only generates file in PNG format, please check your uploaded files.';

        //zip temp cleanup outside loop 
        if ($needCleanup) unlink($img);

        //return with error only after cleanup
        return response($message, 418);
    }

    public function downloadCert(Request $request)
    {
        $cert = Certs::findOrFail($request->certID);

        //random number generator - crash avoidance
        $name = $cert->name . "_" . rand(1000, 9999);

        //zipping files
        $zip = new ZipArchive;
        $zip->open(public_path($name), ZipArchive::CREATE);
        $zip->addFile($cert->imagepath, $name . "." . pathinfo($cert->imagepath, PATHINFO_EXTENSION));
        $zip->close();

        //download?
        return response()->download(public_path($name), $name)->deleteFileAfterSend(true);
    }

    public function registerNotification(Request $request){
        if (!$request->fid) return response("Empty?", 418);
        if (!$request->phone_no && !$request->email) return response("Empty?", 418);

        //add email/phone no to mobileNotification collection
        //but how to obtain client ID :|
    }
}
